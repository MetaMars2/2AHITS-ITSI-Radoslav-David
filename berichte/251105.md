# **Arbeitsbericht vom 05.11.2025**

* **Name:** David Radoslav
* **Klasse:** 2AHITS
* **Gruppe:** 2
* **Fach:** ITSI Übungen
* **Thema:** stdin/stdout

# **Cat**

## **Grundlagen**

Der Befehl `cat` (Kurzform für *concatenate*) wird in Linux verwendet, um den Inhalt von Dateien anzuzeigen, mehrere Dateien zusammenzuführen oder den Inhalt in eine neue Datei zu schreiben.
Er arbeitet direkt mit der **Standard-Eingabe (stdin)** und der **Standard-Ausgabe (stdout)**.


## **Verwendung**

```sh
$ cat datei.txt
```

Dieser Befehl gibt den gesamten Inhalt der Datei `datei.txt` im Terminal aus.

---

### **Mehrere Dateien anzeigen**

```sh
$ cat datei1.txt datei2.txt
```

Die Inhalte beider Dateien werden nacheinander ausgegeben.

---

### **Ausgabe in eine neue Datei schreiben**

Mit dem `>` kann die Ausgabe in eine Datei geschrieben werden:

```sh
$ cat datei1.txt datei2.txt > zusammen.txt
```

Dadurch entsteht eine neue Datei `zusammen.txt`, die den kombinierten Inhalt von `datei1.txt` und `datei2.txt` enthält.

---

### **An eine Datei anhängen**

Mit dem `>>` kann die Ausgabe an eine bestehende Datei angehängt werden:

```sh
$ cat neueZeilen.txt >> zusammen.txt
```

---

### **Von der Tastatur eingeben**

Wenn kein Dateiname angegeben wird, liest `cat` automatisch von der **Standard-Eingabe (stdin)**, also der Tastatur:

```sh
$ cat
Hallo Welt
Das ist ein Test.
^C
```

Mit **Strg+C** wird die Eingabe beendet.

---

## **Wichtige Optionen**

| Option | Bedeutung                         |
| ------ | --------------------------------- |
| `-n`   | Nummeriert alle Ausgabzeilen      |
| `-b`   | Nummeriert nur nicht-leere Zeilen |
| `-s`   | Unterdrückt mehrere leere Zeilen  |
| `-E`   | Zeigt das Zeilenende mit `$` an   |

## **Beispielausgabe**

```sh
$ cat -n text.txt
     1  Hallo Welt
     2  Das ist ein Test.
     3
     4  Noch eine Zeile.
```

## **Übung 1: Kopie mit cat**

**Aufgabe:**
Erstelle mit Hilfe von `cat` eine Kopie der Datei `test.txt` in der neuen Datei `test2.txt`.
`test2.txt` soll den gleichen Inhalt enthalten wie `test.txt`.

**Befehl:**

```sh
$ cat test.txt > test2.txt
```

Wenn der Inhalt der gleichen ist, wurde die Datei erfolgreich kopiert.

---

## **Übung 2: dirlist in File**

**Aufgabe:**
Schreibe den mittels `ls` ermittelten Inhalt des Verzeichnisses `/etc` in eine Textdatei mit dem Namen `etcdir.txt`.

**Befehl:**

```sh
$ ls /etc > etcdir.txt
```

---

## **Übung 3: os-release**

**Aufgabe:**
Betrachte den Inhalt der Datei `/etc/os-release` mit `cat`.

**Befehl:**

```sh
$ cat /etc/os-release
```

**Beispielausgabe:**

```
NAME="Ubuntu"
VERSION="22.04.2 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
PRETTY_NAME="Ubuntu 24.04.2 LTS"
```

**Erklärung:**
Diese Datei enthält Informationen über das installierte Betriebssystem z.B. Name, Version, ID.

**Frage:**
Würde diese Information einem Hacker helfen?
**Antwort:**
Ja, potenziell.
Ein Angreifer könnte gezielt bekannte Sicherheitslücken der angezeigten Linux-Version ausnutzen.

**Darstellung mit `ls -l`:**

```sh
$ ls -l /etc/os-release
```

**Beispielausgabe:**

```
-rw-r--r-- 1 root root 377 Mär 10 09:42 /etc/os-release
```

**Bedeutung:**

* `-rw-r--r--` → Datei ist lesbar für alle, schreibbar nur für root.
* `root root` → Besitzer und Gruppe sind `root`.
* `377` → Dateigröße in Bytes.
* Datum und Uhrzeit -> Zeitpunkt der letzten Änderung.

---

## **Übung 4: Textdatei erstellen**

**Aufgabe:**
Erzeuge nur mit Hilfe von mehreren `echo` Befehlen eine Datei `made_by_echoing.txt` mit folgendem Inhalt:

```
=====================
=    HTL BRAUNAU    =
=====================
= 2AHITS Gruppe 2    =
= 0 Schülerinnen     =
= 14 Schüler         =
=====================
```

**Befehle:**

```sh
$ echo "=====================" > made_by_echoing.txt
$ echo "=    HTL BRAUNAU    =" >> made_by_echoing.txt
$ echo "=====================" >> made_by_echoing.txt
$ echo "= 2AHITS Gruppe 2    =" >> made_by_echoing.txt
$ echo "= 0 Schülerinnen     =" >> made_by_echoing.txt
$ echo "= 14 Schüler         =" >> made_by_echoing.txt
$ echo "=====================" >> made_by_echoing.txt
```

---

## **Übung (C Hallo Welt)**

Befehle zur Erstellung der Datei:

```sh
$ echo '#include <stdio.h>' > hello.c
$ echo '' >> hello.c
$ echo 'int main() {' >> hello.c
$ echo '  printf("\n\t*** Hallo Welt ***\n");' >> hello.c
$ echo '  return 0;' >> hello.c
$ echo '}' >> hello.c
````

$ cat hello.c

Ausgabe:
     *** Hallo Welt ***

---

## **Übung 2.8: Semikolon in der Kommandozeile**

Aufgabe: Mit einem Strich-Punkt (;) getrennt lassen sich zwei Befehle hintereinander in der Kommandozeile schreiben. Diese werden dann nacheinander ausgeführt.

Schreibe mit echo einen Text in eine Datei und gib deren Inhalt sofort danach wieder aus.

Kompiliere das C-Programm und starte es sofort danach.

*Befehl 1 (Textdatei erstellen und anzeigen):*

```sh
$ echo "Das ist ein Test" > test.txt; cat test.txt
```

*Befehl 2 (Kompilieren und Ausführen):*

```sh
$ gcc hello.c -o hello; ./hello
```

Erklärung: Das Semikolon trennt die Befehle.

Aufgabe: Informiere dich über die Here-Documents Schreibweise (Syntax) und führe damit die Aufgabenstellungen "Textdatei erstellen" (HTL Banner) und "C Hallo Welt" noch einmal aus.

Befehl 1 (HTL Banner erstellen):
```sh
$ cat << EOF > made_by_heredoc.txt
=====================
=    HTL BRAUNAU    =
=====================
= 2AHITS Gruppe 2    =
= 0 Schülerinnen     =
= 14 Schüler         =
=====================
EOF
```



Befehl 2 (C Hallo Welt erstellen):
```sh
$ cat << END > hello_heredoc.c
#include <stdio.h>

int main() {
  printf("\n\t*** Hallo Welt via Here-Doc ***\n");
  return 0;
}
END
```


Erklärung: Die Syntax << EOF (oder ein anderer Begrenzer wie END) leitet die folgende Eingabe solange an stdin weiter, bis der Begrenzer in einer neuen Zeile wiederholt wird. cat schreibt diesen Input dann > in die angegebene Datei.